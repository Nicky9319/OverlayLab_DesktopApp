name: Build and Release

on:
  push:
    branches:
      - prod

jobs:
  check:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check if should run
        id: check
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if [[ "$COMMIT_MSG" == *"chore: bump version"* ]]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Skipping workflow - version bump commit detected"
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "Running workflow - code changes detected"
          fi

  version:
    needs: check
    if: needs.check.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install jq for JSON parsing
        run: |
          echo "Installing jq for reliable JSON parsing..."
          sudo apt-get update -qq
          sudo apt-get install -y jq
          jq --version

      - name: Get latest version from OverlayLab_DesktopApp
        id: version
        run: |
          echo "=== Starting version extraction ==="
          echo "Repository: Nicky9319/OverlayLab_DesktopApp"
          
          # Fetch the latest release from the repo
          echo "Fetching latest release from GitHub API..."
          API_URL="https://api.github.com/repos/Nicky9319/OverlayLab_DesktopApp/releases/latest"
          echo "API URL: $API_URL"
          
          API_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" "$API_URL")
          HTTP_STATUS=$(echo "$API_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          API_BODY=$(echo "$API_RESPONSE" | sed '/HTTP_STATUS:/d')
          
          echo "HTTP Status Code: $HTTP_STATUS"
          
          # Log first 500 chars of response for debugging (without exposing sensitive data)
          echo "API Response (first 500 chars):"
          echo "$API_BODY" | head -c 500
          echo ""
          
          # Check if API call was successful
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "⚠️  Warning: API returned status $HTTP_STATUS"
            if [ "$HTTP_STATUS" == "404" ]; then
              echo "Repository or release not found. This might be expected if no releases exist yet."
            fi
          fi
          
          # Try to extract tag_name using multiple methods
          echo "Attempting to extract tag_name..."
          
          # Method 1: Using grep (original method)
          LATEST_VERSION=$(echo "$API_BODY" | grep -o '"tag_name": "[^"]*' | grep -o '[^"]*$' | head -1)
          echo "Method 1 (grep) result: '$LATEST_VERSION'"
          
          # Method 2: Using jq if available (more reliable)
          if command -v jq &> /dev/null; then
            LATEST_VERSION_JQ=$(echo "$API_BODY" | jq -r '.tag_name // empty' 2>/dev/null)
            if [ -n "$LATEST_VERSION_JQ" ] && [ "$LATEST_VERSION_JQ" != "null" ]; then
              echo "Method 2 (jq) result: '$LATEST_VERSION_JQ'"
              LATEST_VERSION="$LATEST_VERSION_JQ"
            fi
          else
            echo "jq not available, using grep method"
          fi
          
          # Method 3: Using sed as fallback
          if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" == "null" ]; then
            LATEST_VERSION_SED=$(echo "$API_BODY" | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p' | head -1)
            echo "Method 3 (sed) result: '$LATEST_VERSION_SED'"
            if [ -n "$LATEST_VERSION_SED" ] && [ "$LATEST_VERSION_SED" != "null" ]; then
              LATEST_VERSION="$LATEST_VERSION_SED"
            fi
          fi
          
          echo "Final extracted version before validation: '$LATEST_VERSION'"
          
          # If no releases exist, use current version from package.json
          if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" == "null" ] || [ "$LATEST_VERSION" == "" ]; then
            echo "⚠️  No valid version found in API response"
            CURRENT_PKG_VERSION=$(node -p "require('./package.json').version")
            LATEST_VERSION="$CURRENT_PKG_VERSION"
            echo "Falling back to current package.json version: $LATEST_VERSION"
          else
            echo "✅ Successfully extracted latest release version: $LATEST_VERSION"
          fi
          
          # Remove 'v' prefix if present
          ORIGINAL_VERSION="$LATEST_VERSION"
          LATEST_VERSION=${LATEST_VERSION#v}
          if [ "$ORIGINAL_VERSION" != "$LATEST_VERSION" ]; then
            echo "Removed 'v' prefix: '$ORIGINAL_VERSION' -> '$LATEST_VERSION'"
          fi
          
          # Increment patch version
          echo "Parsing version components..."
          IFS='.' read -ra VERSION_PARTS <<< "$LATEST_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          echo "Version components - Major: $MAJOR, Minor: $MINOR, Patch: $PATCH"
          
          # Validate version parts are numbers
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "❌ Error: Invalid version format: $LATEST_VERSION"
            echo "Major: '$MAJOR' (valid: $([[ "$MAJOR" =~ ^[0-9]+$ ]] && echo 'yes' || echo 'no'))"
            echo "Minor: '$MINOR' (valid: $([[ "$MINOR" =~ ^[0-9]+$ ]] && echo 'yes' || echo 'no'))"
            echo "Patch: '$PATCH' (valid: $([[ "$PATCH" =~ ^[0-9]+$ ]] && echo 'yes' || echo 'no'))"
            exit 1
          fi
          
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          
          echo "=== Version Calculation Summary ==="
          echo "Current/Latest version: $LATEST_VERSION"
          echo "New version (patch incremented): $NEW_VERSION"
          echo "================================"
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          echo "✅ Version extraction completed successfully"

      - name: Update package.json version
        run: |
          NEW_VERSION="${{ steps.version.outputs.version }}"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            echo "Updating version from $CURRENT_VERSION to $NEW_VERSION"
            npm version $NEW_VERSION --no-git-tag-version
            echo "Updated package.json to version $NEW_VERSION"
          else
            echo "Version is already $NEW_VERSION, skipping update"
          fi

      - name: Commit version update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json package-lock.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }}" || exit 0
          git push origin prod || exit 0

      - name: Create Git Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TAG_NAME="${{ steps.version.outputs.tag }}"
          
          # Fetch tags from remote to check if tag exists
          git fetch --tags --quiet || true
          
          # Check if tag already exists locally
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists locally, skipping creation"
          else
            echo "Creating tag $TAG_NAME"
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME" || exit 0
          fi
          
          # Check if tag exists on remote
          if git ls-remote --tags origin "$TAG_NAME" | grep -q "refs/tags/$TAG_NAME"; then
            echo "Tag $TAG_NAME already exists on remote, skipping push"
          else
            echo "Pushing tag $TAG_NAME to remote"
            git push origin "$TAG_NAME" || exit 0
          fi

  build:
    needs: [check, version]
    if: needs.check.outputs.should_run == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Update version in package.json
        run: |
          NEW_VERSION="${{ needs.version.outputs.version }}"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            echo "Updating version from $CURRENT_VERSION to $NEW_VERSION"
            npm version $NEW_VERSION --no-git-tag-version
          else
            echo "Version is already $NEW_VERSION, skipping update"
          fi

      - name: Build application
        run: npm run build

      - name: Build Windows executable
        if: matrix.os == 'windows-latest'
        run: npm run build:win
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Build macOS executable
        if: matrix.os == 'macos-latest'
        run: |
          # Set up environment variables conditionally
          export GH_TOKEN="${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}"
          
          # Only set code signing variables if secrets exist and are not empty
          if [ -n "${{ secrets.MAC_CERTIFICATE }}" ] && [ -n "${{ secrets.MAC_CERTIFICATE_PASSWORD }}" ]; then
            echo "Code signing certificate found, preparing..."
            echo "${{ secrets.MAC_CERTIFICATE }}" | base64 -d > certificate.p12
            export CSC_LINK="$PWD/certificate.p12"
            export CSC_KEY_PASSWORD="${{ secrets.MAC_CERTIFICATE_PASSWORD }}"
            echo "Code signing enabled"
          else
            echo "No code signing certificate found, building without signing"
            # Don't set CSC_LINK or CSC_KEY_PASSWORD - electron-builder will skip signing
          fi
          
          # Set notarization variables if available
          if [ -n "${{ secrets.APPLE_ID }}" ] && [ -n "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" ]; then
            export APPLE_ID="${{ secrets.APPLE_ID }}"
            export APPLE_APP_SPECIFIC_PASSWORD="${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}"
            echo "Notarization enabled"
          fi
          
          # Run the build
          npm run build:mac

      - name: Upload Windows artifacts
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            dist/**/*.exe
            dist/**/*.zip
          retention-days: 30

      - name: Upload macOS artifacts
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            dist/**/*.dmg
            dist/**/*.zip
          retention-days: 30

  release:
    needs: [check, version, build]
    if: needs.check.outputs.should_run == 'true' && needs.version.outputs.tag != ''
    runs-on: ubuntu-latest
    steps:
      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-build
          path: ./artifacts/windows

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: ./artifacts/macos

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          tag_name: ${{ needs.version.outputs.tag }}
          name: Release ${{ needs.version.outputs.tag }}
          body: |
            ## Release ${{ needs.version.outputs.tag }}
            
            ### Changes
            - Automated build from prod branch
            - Built for Windows and macOS
            
            ### Downloads
            - Windows: See assets below
            - macOS: See assets below
          files: |
            ./artifacts/windows/**/*
            ./artifacts/macos/**/*
          draft: false
          prerelease: false

